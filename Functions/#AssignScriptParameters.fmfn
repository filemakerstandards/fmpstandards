/**
 * =====================================
 * #AssignScriptParameters
 *
 * PURPOSE:
 *		#AssignScriptParameters uses the current script parameter (treated as if
 *		generated by the # function) to declare and populate a series of
 *		locally-scoped script variables. #AssignScriptParameters also uses the
 *		current script name to determine whether or not all required named parameters
 *		are populated (≠ Null). This function is NOT equivalent to 
 *		#Assign ( Get ( ScriptParameter ) ).
 *
 * RETURNS:
 *		True (1) when the script parameter is a valid set of name-value pairs (which
 *		includes the empty string) and all parameters defined as required according to
 *		the script name are non-null; False (0) otherwise.
 *
 * PARAMETERS:
 *		none
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTE:
 *		To be accessible outside this function, variable declarations in the script
 *		parameter must use the $- or $$-prefixed notation for FileMaker variables.
 *		This function does not handle that for you.
 *
 * HISTORY:
 *		MODIFIED on 2010-10-04 by jeremy@kyologic.com to return explicit True or
 *		False values indicating successful evaluation of the script parameter, and to
 *		fit syntax inspired by a comment on standards.filemakermagazine.com by
 *		Richard Dyce.
 *		CREATED on 2010-03-13 by Jeremy Bante of Kyo Logic (jeremy@kyologic.com).
 *		INSPIRED by an example in the FileMaker help documentation.
 *
 * REFERENCES:
 * 		Script Parameter Interface Best Practice
 *		http://filemakerstandards.org/pages/viewpage.action?pageId=557462
 * =====================================
 */
 
Let ( [
	~evaluateString =
		"Let ( [¶"
		& Get ( ScriptParameter )
		& "$void = $void" //terminating variable to keep semicolon-delimited sytax in ScriptParameter consistent
		& "¶];¶"
		& "True¶)"
];
	Case(
		not IsValidExpression ( ~evaluateString );
			False;

		//else, ~evaluateString is a valid expression, so check that required parameters are populated
		Evaluate ( ~evaluateString )
		and
		Let ( [
			//parse required parameters from script name
			~BEGIN = "("; //character marking beginning of named parameters
			//~END = ")"; //character defining end of named parameters
			~DELIMITER = ";"; //character delimiting between named parameters
			~OPTIONAL = "{"; //character marking beginning of optional parameters
			
			~parameters = Substitute ( Get ( ScriptName ) ; ["¶"; ""]; [" "; ""] );
			~beginParameters = Position ( ~parameters ; ~BEGIN ; 1 ; 1 );
			~endParameters = Position ( ~parameters ; ~OPTIONAL ; 1 ; 1 );
			~endParameters = Case ( not ~endParameters ; Length ( ~parameters ) ; ~endParameters );
			~parameters = Middle ( ~parameters ; ~beginParameters + 1 ; ~endParameters - ~beginParameters - 1 );
			~parameters = Substitute (
									Trim ( ~parameters ) & "☠";
									[ ~DELIMITER & "☠" ; "" ]; //remove possible erroneous trailing delimiter
									[ "☠" ; "" ];
									[ ~DELIMITER ; "¶" ]
							)
		];
			//check that required parameters are non-null
			Case (
				~beginParameters and Length ( ~parameters ); //script name specifies parameters
					Evaluate ( //string returns true when all required parameters are populated
						"Length ( $"
						& Substitute ( ~parameters ; "¶" ; " ) and Length ( $" )
						& " )"
					);

				//else, parameters are adequate by default when not required in script name
				True
			)
		)
	)
)